Домашно 2
===

Краен срок за предаване: 2016.03.17 23:59:59

Задача 1 - Минимакс
---
Точки: 7

Напишете функцията `void minmax(int *arr, int size, int *min, int *max)`, която намира най-големия и най-малкия елемент в масивът arr с големина size чрез едно обхождане през него.

На първия ред от стандартния вход прочитате големината на масива - n. На следващия ред прочитате елементите на масива.

Изведете на стандартния изход сумата на двата елемента.

Примерен вход:
```
5
6 3 1 17 -22
```
Изход:
```
-5
```
**Ограничения:**
- Числата ще бъдат целочислени
- Максимална големина на масива 500
- Масивът има поне един елемент

Задача 2 - Seek & !Destroy
---
Точки: 7

Да се дефинира функция `char* find(char *haystack, char needle)`, която намира първото срещане на needle в haystack и връща указател към съответния елемент. Ако needle няма нито едно срещане в haystack да се върне `NULL` указател.

Четем от стандартния вход цял ред (до срещане на '\\n') и на новия ред символа, който да търсим.

На стандартния изход да се изведе индекса на елемента в масива или ако елемента не се среща да се изведе -1.

**Ограничения:**
- Редът за търсене може да има най-много 400 символа
- **Използвайте функцията find**
- printf фунцкията трябва да се извиква в main, не във find.

**Пояснение:**
- Адресите в масив са последоветелни


Примерен вход:
```
az sym gencho hybaveca vechniq ergen
y
```
Изход:
```
4
```

Задача 3 - Za.io
---
Точки: 12

Дефинирайте помощна фунцкия `int* hop(int *elem)`, която получала указател и връща указател равен на входния отместен със стойността към която сочи той. Да се дефинира втора помощна фунцкия `int is_in_bound(int *arr, int size, int *ptr)`, която връща(**!= принтира**) дали даденият указател(ptr) сочи към елемент от масива(arr).

Целта на програмата е да достигне елемент със стойност '0' в масива.

Oт стандартния вход се чете масив от целочислени стойности до достигане на `EOF`.

На първия ред от стандартния изход да се изведе 0 или 1 в зависимост от това дали има **път** до елемента със стойност 0.
На следващия ред от стандартния изход да се изведе колко подскока(hops) са направении преди да се достигне до едно от следните:
  1. Достигане на елемента със стойност '0'
  2. Не излезем извън границите на масива(функцията is_in_bound)
  3. Не направим 50 подскока без достигане на някоя от другите targets

Началото на всеки **път** е нулевия елемент на масива. На поредната стъпка от пътя към текущата позиция добавяме стойността на елемента към който сочим (функцията hop).

**Ограничения:**
- Може да имаме максимално 50 хопа
- Максимална големина на масива 50 елемента
- Стойностите на масива ще бъдат положителни и отрицателни целочислени числа

Примерен вход:
```
1 3 3 0 -2 -2
```
Изход:
```
1
5
```

Примерен вход:
```
1 3 2 0 -2 -2
```
Изход:
```
0
50
```


Примерен вход:
```
1 8 2 1 -2 -2
```
Изход:
```
0
2
```
